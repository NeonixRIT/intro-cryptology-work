from os import environ
from random import SystemRandom
from sys import byteorder
from typing import Any

from math import frexp, isinf, isfinite
from sys import maxsize

"""
Reference: https://github.com/python/cpython

Attempt to fully implement Python's hash() function in python

Notes:
Hash return value of -1 is reserved as an error code

By default Python uses SipHash-1-3 with a random seed to hash strings and bytes
Python hash seed can be changed using PYTHONHASHSEED environment variable
    'random' - random seed
    0, 4294967295 - convert string to u long and use as seed
    seed = strtoul(seed_text, (char **)&endptr, 10);


It has different methods for hashing different types of objects
It implements a separate hash function for:
    integers
    doubles
    pointers
    generic objects (uses pointer)
    bytes/strings

For small bytes/strings it uses a simpler hash for optimization
    djbx33a

by default this cuttoff is 5 bytes for 32-bit systems and 7 bytes for 64-bit systems - old its now 0

However, the hash function and variables are dependent on a few things
    1. System architecture/platform
        If memory allignment is required
            the hash function is FNV
        Otherwise, by default
            the hash function is siphash-1-3
    2. Python version
        Python 3.4 and later
            use siphash
        Python 3.3 and earlier
            use FNV hash
    3. Platform bandwidth
    This changes _PyHASH_BITS
        32-bit
            _PyHASH_BITS = 31
        64-bit
            _PyHASH_BITS = 61


/* Prime multiplier used in string and various other hashes. */
#define _PyHASH_MULTIPLIER 1000003UL  /* 0xf4243 */

/* Parameters used for the numeric hash implementation.  See notes for
   _Py_HashDouble in Python/pyhash.c.  Numeric hashes are based on
   reduction modulo the prime 2**_PyHASH_BITS - 1. */

#if SIZEOF_VOID_P >= 8
#  define PyHASH_BITS 61
#else
#  define PyHASH_BITS 31
#endif

#define PyHASH_MODULUS (((size_t)1 << _PyHASH_BITS) - 1)
#define PyHASH_INF 314159
#define PyHASH_IMAG _PyHASH_MULTIPLIER


/* hash function definition */
typedef struct {
    Py_hash_t (*const hash)(const void *, Py_ssize_t);
    const char *name;
    const int hash_bits;
    const int seed_bits;
} PyHash_FuncDef;

static PyHash_FuncDef PyHash_Func = {fnv, "fnv", 8 * SIZEOF_PY_HASH_T,
                                     16 * SIZEOF_PY_HASH_T};
static PyHash_FuncDef PyHash_Func = {pysiphash, "siphash13", 64, 128};
static PyHash_FuncDef PyHash_Func = {pysiphash, "siphash24", 64, 128};

/* Py_hash_t is the same size as a pointer. */
#define SIZEOF_PY_HASH_T SIZEOF_SIZE_T
typedef Py_ssize_t Py_hash_t;
/* Py_uhash_t is the unsigned equivalent needed to calculate numeric hash. */
#define SIZEOF_PY_UHASH_T SIZEOF_SIZE_T


There is also an option for a custom/external hash function to be used.

#define Py_HASH_EXTERNAL 0
#define Py_HASH_SIPHASH24 1
#define Py_HASH_FNV 2
#define Py_HASH_SIPHASH13 3


/* Hash secret
 *
 * memory layout on 64 bit systems
 *   cccccccc cccccccc cccccccc  uc -- unsigned char[24]
 *   pppppppp ssssssss ........  fnv -- two Py_hash_t
 *   k0k0k0k0 k1k1k1k1 ........  siphash -- two uint64_t
 *   ........ ........ ssssssss  djbx33a -- 16 bytes padding + one Py_hash_t
 *   ........ ........ eeeeeeee  pyexpat XML hash salt
 *
 * memory layout on 32 bit systems
 *   cccccccc cccccccc cccccccc  uc
 *   ppppssss ........ ........  fnv -- two Py_hash_t
 *   k0k0k0k0 k1k1k1k1 ........  siphash -- two uint64_t (*)
 *   ........ ........ ssss....  djbx33a -- 16 bytes padding + one Py_hash_t
 *   ........ ........ eeee....  pyexpat XML hash salt
 *
 * (*) The siphash member may not be available on 32 bit platforms without
 *     an unsigned int64 data type.
 */


 /* Fill buffer with pseudo-random bytes generated by a linear congruent
   generator (LCG):

       x(n+1) = (x(n) * 214013 + 2531011) % 2^32

   Use bits 23..16 of x(n) to generate a byte. */
static void
lcg_urandom(unsigned int x0, unsigned char *buffer, size_t size)
{
    size_t index;
    unsigned int x;

    x = x0;
    for (index=0; index < size; index++) {
        x *= 214013;
        x += 2531011;
        /* modulo 2 ^ (8 * sizeof(int)) */
        buffer[index] = (x >> 16) & 0xff;
    }
}

/* Initialize the hash secrets using seed. */
Py_ssize_t secret_size = sizeof(_Py_HashSecret_t); # should be 24 w/ only 20 being used for 32-bit systems
lcg_urandom(config->hash_seed, secret, secret_size);


typedef union {
    /* ensure 24 bytes */
    unsigned char uc[24];
    /* two Py_hash_t for FNV */
    struct {
        Py_hash_t prefix;
        Py_hash_t suffix;
    } fnv;
    /* two uint64 for SipHash24 */
    struct {
        uint64_t k0;
        uint64_t k1;
    } siphash;
    /* a different (!) Py_hash_t for small string optimization */
    struct {
        unsigned char padding[16];
        Py_hash_t suffix;
    } djbx33a;
    struct {
        unsigned char padding[16];
        Py_hash_t hashsalt;
    } expat;
} _Py_HashSecret_t;
"""

# Python hash/config constants
# Supposed to change based on system architechture
# TODO: refactor into object
CUTOFF = 0
SIZEOF_PY_HASH_T = 8 if maxsize.bit_length() > 32 else 4
HASH_INF = 314159
HASH_MULTIPLIER = 1000003  # 0xf4243 # 1000003
HASH_IMAG = HASH_MULTIPLIER
HASH_BITS = 61 if SIZEOF_PY_HASH_T >= 8 else 31
HASH_MODULUS = (1 << HASH_BITS) - 1
HASH_XXPRIME_1 = 11400714785074694791
HASH_XXPRIME_2 = 14029467366897019727
HASH_XXPRIME_5 = 2870177450012600261


# xxHash Function Definitions for hashing Tuples
def HASH_XXROTATE64(x: int) -> int:
    # rotate left 31 bits
    return ((x << 31) | (x >> 33)) & 0xFFFFFFFFFFFFFFFF


def HASH_XXROTATE32(x: int) -> int:
    # rotate left 13 bits
    return ((x << 13) | (x >> 13)) & 0xFFFFFFFF


HASH_XXROTATE = HASH_XXROTATE64 if SIZEOF_PY_HASH_T == 8 else HASH_XXROTATE32

if SIZEOF_PY_HASH_T == 4:
    HASH_XXPRIME_1 = 2654435761
    HASH_XXPRIME_2 = 2246822519
    HASH_XXPRIME_5 = 374761393


# Check if PYTHONHASHSEED is environment variable is set
# If not set: use random seed, if it is: ensure it is a valid integer and use it as seed
HASH_SEED = environ.get('PYTHONHASHSEED', 'random').strip()
if HASH_SEED != 'random':
    if HASH_SEED.isdigit() and (0 <= int(HASH_SEED) <= 4294967295):
        HASH_SEED = int(HASH_SEED)
    else:
        raise RuntimeError('Fatal Python error: config_init_hash_seed: PYTHONHASHSEED must be "random" or an integer in range [0; 4294967295]')


# Function used to generate hash secret based on seed
def lcg_urandom(x0, size) -> bytes:
    buffer = []
    x = x0 & 0xFFFFFFFF
    for _ in range(size):
        x = (x * 214013 + 2531011) & 0xFFFFFFFF
        buffer.append((x >> 16) & 0xFF)
    return bytes(buffer)


# true random function
def pyurandom(size: int) -> bytes:
    return SystemRandom().randbytes(size)


# Set the hash secret based on seed
U = pyurandom(24) if HASH_SEED == 'random' else lcg_urandom(HASH_SEED, 24)


# Helper functions for hashing
def _u64tos(x: int):
    """
    Convert to signed 64-bit integer
    """
    return (x + (1 << 63)) % (1 << 64) - (1 << 63)


def _le64toh(x: int):
    """
    Convert little-endian 64-bit integer to host byte order
    """
    if byteorder == 'little':
        return x
    return int.from_bytes(x.to_bytes(8, 'little'), 'big')


def rotl64(x, b):
    return ((x << b) & 0xFFFFFFFFFFFFFFFF) | (x >> (64 - b))


def rotr64(x, b):
    return (x >> b) | ((x << (64 - b)) & 0xFFFFFFFFFFFFFFFF)


# SipHash Functions
def half_round(a, b, c, d, s, t):
    a = (a + b) & 0xFFFFFFFFFFFFFFFF
    c = (c + d) & 0xFFFFFFFFFFFFFFFF
    b = rotl64(b, s) ^ a
    d = rotl64(d, t) ^ c
    a = rotl64(a, 32)
    return a, b, c, d


def single_round(v0, v1, v2, v3):
    v0, v1, v2, v3 = half_round(v0, v1, v2, v3, 13, 16)
    v2, v1, v0, v3 = half_round(v2, v1, v0, v3, 17, 21)
    return v0, v1, v2, v3


def double_round(v0, v1, v2, v3):
    v0, v1, v2, v3 = single_round(v0, v1, v2, v3)
    return single_round(v0, v1, v2, v3)


def siphash13(k0: int, k1: int, src: bytes) -> int:
    src_sz = len(src) & 0xFF
    b = src_sz << 56

    v0 = k0 ^ 0x736F6D6570736575
    v1 = k1 ^ 0x646F72616E646F6D
    v2 = k0 ^ 0x6C7967656E657261
    v3 = k1 ^ 0x7465646279746573

    # Process the message in 8-byte chunks
    # convert each 8 byte chunk of the src to the endianness of the host machine
    while src_sz >= 8:
        d = src[:8]
        mi = _le64toh(int.from_bytes(d, 'little'))
        v3 ^= mi
        v0, v1, v2, v3 = single_round(v0, v1, v2, v3)
        v0 ^= mi
        src = src[8:]
        src_sz -= len(d)

    pt = [0] * 8
    for i in range(src_sz - 1, -1, -1):
        pt[i] = src[i]
    t = _le64toh(int.from_bytes(bytes(pt), 'little'))
    b |= t

    # compression
    v3 ^= b
    v0, v1, v2, v3 = single_round(v0, v1, v2, v3)
    v0 ^= b

    # finalization
    v2 ^= 0xFF
    v0, v1, v2, v3 = single_round(v0, v1, v2, v3)
    v0, v1, v2, v3 = single_round(v0, v1, v2, v3)
    v0, v1, v2, v3 = single_round(v0, v1, v2, v3)

    # print(bin(v0)[2:].zfill(64), bin(v1)[2:].zfill(64), bin(v2)[2:].zfill(64), bin(v3)[2:].zfill(64), '', sep='\n')
    t = (v0 ^ v1) ^ (v2 ^ v3)
    return _u64tos(t)


def siphash24(k0: int, k1: int, src: bytes) -> int:
    src_sz = len(src)
    b = src_sz << 56
    v0 = k0 ^ 0x736F6D6570736575
    v1 = k1 ^ 0x646F72616E646F6D
    v2 = k0 ^ 0x6C7967656E657261
    v3 = k1 ^ 0x7465646279746573

    # Process the message in 8-byte chunks
    # convert each 8 byte chunk of the src to the endianness of the host machine
    while src_sz >= 8:
        d = src[:8]
        mi = _le64toh(int.from_bytes(d, 'little'))
        v3 ^= mi
        v0, v1, v2, v3 = double_round(v0, v1, v2, v3)
        v0 ^= mi
        src = src[8:]
        src_sz -= len(d)

    pt = [0] * 8
    for i in range(src_sz - 1, -1, -1):
        pt[i] = src[i]
    t = int.from_bytes(bytes(pt), 'little')
    b |= _le64toh(t)

    # compression
    v3 ^= b
    v0, v1, v2, v3 = double_round(v0, v1, v2, v3)
    v0 ^= b

    # finalization
    v2 ^= 0xFF
    v0, v1, v2, v3 = double_round(v0, v1, v2, v3)
    v0, v1, v2, v3 = double_round(v0, v1, v2, v3)

    t = (v0 ^ v1) ^ (v2 ^ v3)
    return _u64tos(t)


# Hash functions for different types
def python_hash_integer(data: int) -> int:
    """
    Python's hash function for integers.

    0x1fffffffffffffff is the hex (base16) representation of 2 ** 61 - 1
    """
    if data < 0:
        return -((-data) % 0x1FFFFFFFFFFFFFFF)
    return data % 0x1FFFFFFFFFFFFFFF


def djbx33a(data: bytes, suffix: bytes) -> int:
    """
    Hash function used for small strings in Python.
    """
    # ((h << 5) + h) + byte == h * 33 + byte
    h = 5381
    for byte in data:
        h = ((h << 5) + h) + byte
    h ^= len(data)
    h ^= int.from_bytes(suffix, 'little')
    # h = h if h & 0x8000000000000000 == 0 else h - 0x10000000000000000
    return _u64tos(h)


def python_hash_pointer(pointer: int):
    return rotr64(pointer, 4)


def python_hash_bytes(data: bytes):
    # TODO: change alg based on a config
    if len(data) < CUTOFF:  # use separate function for small strings
        return djbx33a(data, U[16:])
    else:
        return siphash13(_le64toh(int.from_bytes(U[:8], 'little')), _le64toh(int.from_bytes(U[8:16], 'little')), data)


def python_hash_string(data: str):
    # turn string into a list of ascii values (bytes)
    data = data.encode()
    return python_hash_bytes(data)


def python_hash_double(v: float):
    if not isfinite(v):
        if isinf(v):
            return HASH_INF if v > 0 else -HASH_INF
        else:
            return python_hash_pointer(id(v))

    m, e = frexp(v)

    sign = 1
    if m < 0:
        sign = -1
        m = -m

    x = 0
    while m:
        x = ((x << 28) & 0x1FFFFFFFFFFFFFFF) | x >> (61 - 28)
        m *= 268435456.0
        e -= 28
        y = int(m)
        m -= y
        x += y
        if x >= 0x1FFFFFFFFFFFFFFF:
            x -= 0x1FFFFFFFFFFFFFFF

    e = e % 61 if e >= 0 else 61 - 1 - ((-1 - e) % 61)
    x = ((x << e) & 0x1FFFFFFFFFFFFFFF) | x >> (61 - e)

    return x * sign


def python_hash_tuple(data: tuple) -> int:
    """
    Python's hash function for tuples.

    Version of xxHash on each element of the tuple and combine the results.
    """
    data_len = len(data)

    acc = HASH_XXPRIME_5
    for i in range(data_len):
        lane = python_hash(data[i])
        if lane == -1:
            return -1
        acc = (acc + (lane * HASH_XXPRIME_2)) & 0xFFFFFFFFFFFFFFFF
        acc = HASH_XXROTATE(acc)
        acc = (acc * HASH_XXPRIME_1) & 0xFFFFFFFFFFFFFFFF

    acc = (acc + (data_len ^ HASH_XXPRIME_5 ^ 3527539)) & 0xFFFFFFFFFFFFFFFF

    if acc == -1:
        return 1546275796
    return _u64tos(acc)


# Main hash function
def python_hash(data: Any) -> int:
    """
    main function to hash data.

    does not respect object's __hash__ functions
    but does respect __pyhash__ functions
        __pyhash__ must return a representation of the object in a base hashable type
        This should be the same state used in an object's __eq__

    Does not currently handle slice, range, or memoryview objects like python does
    """
    # respect __pyhash__ functions
    if getattr(data, '__pyhash__', None) is not None:
        data = data.__pyhash__()
        hash_value = python_hash(data)
        return -2 if hash_value == -1 else hash_value

    # unhashable types raise error
    # isinstance(data, (list, dict, set, bytearray, memoryview))
    if getattr(data, '__hash__', None) is None:
        raise TypeError(f'unhashable type: {type(data).__name__}')

    # Hashable base types
    hash_value = 0
    if isinstance(data, int):
        hash_value = python_hash_integer(data)
    elif isinstance(data, bytes):
        hash_value = python_hash_bytes(data)
    elif isinstance(data, str):
        hash_value = python_hash_string(data)
    elif isinstance(data, float):
        hash_value = python_hash_double(data)
    elif isinstance(data, tuple):
        hash_value = python_hash_tuple(data)
    elif isinstance(data, object):
        hash_value = python_hash_pointer(id(data))
    else: # should never be reached since all data types should be objects
        raise TypeError(f'unhashable type: {type(data).__name__}')

    if hash_value == -1:
        hash_value = -2
    return hash_value


# Compare builtin hash with this implementation of various types to ensure same hashes are computed
def main():
    """
    Run with setting the PYTHONHASHSEED environment variable so computed and python hashes match
    e.g.
        PYTHONHASHSEED=100 python pyhash.py
    """

    def random_string(length: int) -> str:
        return ''.join(chr(SystemRandom().randrange(97, 123)) for _ in range(length))

    class TestObject:
        def __init__(self, name):
            self.name = name
        def __str__(self):
            return f'TestObject({self.name=}, ptr={id(self)})'

    rand_string = random_string(20)
    rand_bytes = random_string(20).encode()
    rand_int = SystemRandom().randint(0, 1000000000)
    rand_double = SystemRandom().random()
    rand_obj = TestObject(rand_string)
    rand_tup = tuple([SystemRandom().randint(0, 11) for _ in range(SystemRandom().randint(0, 11))])

    things_to_hash = [rand_string, rand_bytes, rand_int, rand_double, rand_tup, rand_obj]
    print(things_to_hash)
    for obj in things_to_hash:
        res1 = python_hash(obj)
        res2 = hash(obj)

        print(f'Object ({type(obj).__name__})'.ljust(21), f': {obj}')
        print(f'\tComputed hash : {res1}')
        print(f'\tPython hash   : {res2}')
        print()


if __name__ == '__main__':
    main()
